{"mappings":"AAAA,gEAAgE;AAChE,iFAAiF;AAEjF,yCAAyC;AACzC,IAAI,iBAAiB,gBAAgB,gBAAgB;AAErD,6BAA6B;AAC7B,IAAI,iBAAiB;AACrB,IAAI,iBAAiB;AACrB,IAAI,iBAAiB;AACrB,IAAI,gBAAgB;AAEpB,8BAA8B;AAC9B,eAAe,oBAAoB,MAAM;IACvC,IAAI;QACF,QAAQ,GAAG,CAAC;QACZ,MAAM,gBAAgB,YAAY,GAAG;QAErC,wCAAwC;QACxC,IAAI;YACF,6CAA6C;YAC7C,KAAK,aAAa,CAAC;QACrB,EAAE,OAAO,GAAG;YACV,QAAQ,IAAI,CAAC,kEAAkE;YAC/E,IAAI;gBACF,kBAAkB;gBAClB,KAAK,aAAa,CAAC;YACrB,EAAE,OAAO,IAAI;gBACX,QAAQ,KAAK,CAAC,+CAA+C;gBAC7D,MAAM,IAAI,MAAM,uCAAuC,GAAG,OAAO;YACnE;QACF;QAEA,MAAM,aAAa,YAAY,GAAG,KAAK;QACvC,QAAQ,GAAG,CAAC,CAAC,8BAA8B,EAAE,KAAK,KAAK,CAAC,YAAY,EAAE,CAAC;QAEvE,wCAAwC;QACxC,kBAAkB,KAAK,eAAe;QACtC,iBAAiB,KAAK,cAAc;QACpC,iBAAiB,KAAK,cAAc;QACpC,iBAAiB,KAAK,cAAc;QAEpC,qDAAqD;QACrD,MAAM,SAAS,MAAM,gBAAgB,cAAc,CACjD,OAAO,QAAQ,IAAI;QAGrB,MAAM,eAAe,YAAY,GAAG,KAAK,gBAAgB;QACzD,QAAQ,GAAG,CAAC,CAAC,6BAA6B,EAAE,KAAK,KAAK,CAAC,cAAc,EAAE,CAAC;QAExE,2DAA2D;QAC3D,mDAAmD;QACnD,MAAM,YAAY,OAAO,SAAS,IAChC;QAEF,QAAQ,GAAG,CAAC,CAAC,qBAAqB,EAAE,WAAW;QAE/C,4BAA4B;QAC5B,iBAAiB,MAAM,eAAe,iBAAiB,CAAC,QAAQ;YAC9D,aAAa;gBACX,gBAAgB;gBAChB,UAAU,OAAO,QAAQ,IAAI;YAC/B;YACA,aAAa;YACb,UAAU;YACV,4BAA4B,OAAO,aAAa,IAAI;YACpD,2BAA2B,OAAO,aAAa,IAAI;YACnD,uBAAuB,OAAO,qBAAqB,IAAI;YACvD,yBAAyB;QAC3B;QAEA,MAAM,gBAAgB,YAAY,GAAG,KAAK;QAC1C,QAAQ,GAAG,CAAC,CAAC,kCAAkC,EAAE,KAAK,KAAK,CAAC,eAAe,EAAE,CAAC;QAE9E,qDAAqD;QACrD,IAAI,OAAO,mBAAmB,EAC5B,iBAAiB,MAAM,eAAe,iBAAiB,CAAC,QAAQ;YAC9D,aAAa;gBACX,gBAAgB;gBAChB,UAAU,OAAO,QAAQ,IAAI;YAC/B;YACA,aAAa;YACb,UAAU;YACV,4BAA4B;YAC5B,2BAA2B;YAC3B,uBAAuB;YACvB,uBAAuB;QACzB;QAGF,qDAAqD;QACrD,IAAI,OAAO,mBAAmB,EAC5B,iBAAiB,MAAM,eAAe,iBAAiB,CAAC,QAAQ;YAC9D,aAAa;gBACX,gBAAgB;gBAChB,UAAU,OAAO,QAAQ,IAAI;YAC/B;YACA,aAAa;YACb,UAAU;YACV,4BAA4B;YAC5B,2BAA2B;YAC3B,uBAAuB;QACzB;QAGF,OAAO;YAAE,SAAS;QAAK;IACzB,EAAE,OAAO,OAAO;QACd,OAAO;YACL,SAAS;YACT,OAAO,MAAM,OAAO,IAAI;QAC1B;IACF;AACF;AAEA,wBAAwB;AACxB,SAAS,kBAAkB,SAAS,EAAE,KAAK,EAAE,MAAM,EAAE,SAAS;IAC5D,IAAI;QACF,IAAI,CAAC,gBACH,OAAO;YAAE,OAAO;QAAiC;QAGnD,+DAA+D;QAC/D,MAAM,QAAQ;YACZ,MAAM,IAAI,WAAW;YACrB,OAAO;YACP,QAAQ;QACV;QAEA,wCAAwC;QACxC,IAAI,cAAc,eAChB,OAAO;YAAE,YAAY;QAAK;QAG5B,+BAA+B;QAC/B,MAAM,cAAc,eAAe,cAAc,CAAC,OAAO;QAEzD,4CAA4C;QAC5C,IAAI,cAAc;QAClB,IAAI,gBACF,cAAc,eAAe,cAAc,CAAC,OAAO;QAGrD,4CAA4C;QAC5C,IAAI,cAAc;QAClB,IAAI,gBACF,cAAc,eAAe,cAAc,CAAC,OAAO;QAGrD,mBAAmB;QACnB,gBAAgB;QAEhB,2BAA2B;QAC3B,OAAO;YACL,MAAM;YACN,MAAM;YACN,MAAM;YACN,WAAW;QACb;IACF,EAAE,OAAO,OAAO;QACd,OAAO;YACL,OAAO,MAAM,OAAO,IAAI;YACxB,OAAO,MAAM,KAAK;QACpB;IACF;AACF;AAEA,2CAA2C;AAC3C,KAAK,SAAS,GAAG,OAAO;IACtB,MAAM,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG,MAAM,IAAI;IAEjC,OAAQ;QACN,KAAK;YACH,MAAM,aAAa,MAAM,oBAAoB,KAAK,MAAM;YACxD,KAAK,WAAW,CAAC;gBAAE,MAAM;gBAAe,MAAM;YAAW;YACzD;QAEF,KAAK;YACH,MAAM,SAAS,kBACb,KAAK,SAAS,EACd,KAAK,KAAK,EACV,KAAK,MAAM,EACX,KAAK,SAAS;YAEhB,KAAK,WAAW,CAAC;gBACf,MAAM;gBACN,MAAM;YACR;YACA;QAEF,KAAK;YACH,6DAA6D;YAC7D,IAAI,KAAK,mBAAmB,KAAK,WAAW;gBAC1C,mDAAmD;gBACnD,MAAM,eAAe,MAAM,oBAAoB;gBAC/C,KAAK,WAAW,CAAC;oBAAE,MAAM;oBAAkB,MAAM;gBAAa;YAChE;YACA;QAEF;YACE,KAAK,WAAW,CAAC;gBACf,MAAM;gBACN,MAAM;oBAAE,OAAO,CAAC,sBAAsB,EAAE,MAAM;gBAAC;YACjD;IACJ;AACF","sources":["src/workers/mediapipeWorker.js"],"sourcesContent":["// MediaPipe Worker - Handles pose detection off the main thread\n// Classic worker (not module) to allow MediaPipe to use importScripts internally\n\n// Store references for MediaPipe classes\nlet FilesetResolver, PoseLandmarker, FaceLandmarker, HandLandmarker;\n\n// Store landmarker instances\nlet poseLandmarker = null;\nlet faceLandmarker = null;\nlet handLandmarker = null;\nlet lastVideoTime = -1;\n\n// Initialize MediaPipe models\nasync function initializeMediaPipe(config) {\n  try {\n    console.log('Worker: Starting MediaPipe initialization');\n    const initStartTime = performance.now();\n    \n    // Try to load MediaPipe from local file\n    try {\n      // Use local file path relative to the worker\n      self.importScripts('/vendor/mediapipe/vision_bundle.js');\n    } catch (e) {\n      console.warn('Failed to load MediaPipe from local path, trying CDN fallback:', e);\n      try {\n        // Fallback to CDN\n        self.importScripts('https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js');\n      } catch (e2) {\n        console.error('Failed to load MediaPipe from fallback CDN:', e2);\n        throw new Error('Failed to load MediaPipe library: ' + e2.message);\n      }\n    }\n    \n    const importTime = performance.now() - initStartTime;\n    console.log(`Worker: MediaPipe import took ${Math.round(importTime)}ms`);\n    \n    // Assign the globals to local variables\n    FilesetResolver = self.FilesetResolver;\n    PoseLandmarker = self.PoseLandmarker;\n    FaceLandmarker = self.FaceLandmarker;\n    HandLandmarker = self.HandLandmarker;\n    \n    // Configure vision tasks path - use local wasm files\n    const vision = await FilesetResolver.forVisionTasks(\n      config.wasmPath || '/vendor/mediapipe/wasm'\n    );\n    \n    const resolverTime = performance.now() - initStartTime - importTime;\n    console.log(`Worker: FilesetResolver took ${Math.round(resolverTime)}ms`);\n\n    // Choose the appropriate model based on device performance\n    // Use lite model by default for better performance\n    const modelPath = config.modelPath || \n      '/vendor/mediapipe/models/pose_landmarker_lite.task';\n      \n    console.log(`Worker: Using model: ${modelPath}`);\n    \n    // Initialize PoseLandmarker\n    poseLandmarker = await PoseLandmarker.createFromOptions(vision, {\n      baseOptions: {\n        modelAssetPath: modelPath,\n        delegate: config.delegate || 'GPU',\n      },\n      runningMode: 'VIDEO',\n      numPoses: 1,\n      minPoseDetectionConfidence: config.minConfidence || 0.5,\n      minPosePresenceConfidence: config.minConfidence || 0.5,\n      minTrackingConfidence: config.minTrackingConfidence || 0.5,\n      outputSegmentationMasks: false,\n    });\n    \n    const totalInitTime = performance.now() - initStartTime;\n    console.log(`Worker: Total initialization took ${Math.round(totalInitTime)}ms`);\n\n    // Conditionally initialize FaceLandmarker if enabled\n    if (config.enableFaceLandmarks) {\n      faceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n        baseOptions: {\n          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker/float16/1/face_landmarker.task',\n          delegate: config.delegate || 'GPU'\n        },\n        runningMode: 'VIDEO',\n        numFaces: 1,\n        minFaceDetectionConfidence: 0.5,\n        minFacePresenceConfidence: 0.5,\n        minTrackingConfidence: 0.5,\n        outputFaceBlendshapes: false,\n      });\n    }\n\n    // Conditionally initialize HandLandmarker if enabled\n    if (config.enableHandLandmarks) {\n      handLandmarker = await HandLandmarker.createFromOptions(vision, {\n        baseOptions: {\n          modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task',\n          delegate: config.delegate || 'GPU'\n        },\n        runningMode: 'VIDEO',\n        numHands: 2,\n        minHandDetectionConfidence: 0.5,\n        minHandPresenceConfidence: 0.5,\n        minTrackingConfidence: 0.5,\n      });\n    }\n\n    return { success: true };\n  } catch (error) {\n    return { \n      success: false, \n      error: error.message || 'Unknown error initializing MediaPipe'\n    };\n  }\n}\n\n// Process a video frame\nfunction processVideoFrame(imageData, width, height, timestamp) {\n  try {\n    if (!poseLandmarker) {\n      return { error: 'PoseLandmarker not initialized' };\n    }\n\n    // Convert the imageData to an object the MediaPipe can process\n    const image = {\n      data: new Uint8Array(imageData),\n      width: width,\n      height: height,\n    };\n\n    // Skip if same timestamp (no new frame)\n    if (timestamp === lastVideoTime) {\n      return { noNewFrame: true };\n    }\n    \n    // Process with pose landmarker\n    const poseResults = poseLandmarker.detectForVideo(image, timestamp);\n    \n    // Process with face landmarker if available\n    let faceResults = null;\n    if (faceLandmarker) {\n      faceResults = faceLandmarker.detectForVideo(image, timestamp);\n    }\n    \n    // Process with hand landmarker if available\n    let handResults = null;\n    if (handLandmarker) {\n      handResults = handLandmarker.detectForVideo(image, timestamp);\n    }\n    \n    // Update timestamp\n    lastVideoTime = timestamp;\n\n    // Return processed results\n    return {\n      pose: poseResults,\n      face: faceResults,\n      hand: handResults,\n      timestamp: timestamp\n    };\n  } catch (error) {\n    return { \n      error: error.message || 'Error processing video frame',\n      stack: error.stack\n    };\n  }\n}\n\n// Listen for messages from the main thread\nself.onmessage = async (event) => {\n  const { type, data } = event.data;\n\n  switch (type) {\n    case 'INIT':\n      const initResult = await initializeMediaPipe(data.config);\n      self.postMessage({ type: 'INIT_RESULT', data: initResult });\n      break;\n      \n    case 'PROCESS_FRAME':\n      const result = processVideoFrame(\n        data.imageData, \n        data.width, \n        data.height, \n        data.timestamp\n      );\n      self.postMessage({ \n        type: 'PROCESS_RESULT', \n        data: result\n      });\n      break;\n      \n    case 'UPDATE_CONFIG':\n      // Handle config updates (e.g., toggling face/hand detection)\n      if (data.enableFaceLandmarks !== undefined) {\n        // Reinitialize MediaPipe with new config if needed\n        const reinitResult = await initializeMediaPipe(data);\n        self.postMessage({ type: 'CONFIG_UPDATED', data: reinitResult });\n      }\n      break;\n      \n    default:\n      self.postMessage({ \n        type: 'ERROR', \n        data: { error: `Unknown message type: ${type}` } \n      });\n  }\n}; "],"names":[],"version":3,"file":"mediapipeWorker.878e1795.js.map","sourceRoot":"/__parcel_source_root/"}